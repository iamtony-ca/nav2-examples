#include "amr_bt_nodes/advanced_remove_passed_goals_action.hpp"

#include <functional>
#include <numeric>

#include "nav2_util/robot_utils.hpp"
#include "nav2_util/geometry_utils.hpp"
#include "tf2_geometry_msgs/tf2_geometry_msgs.hpp"

namespace amr_bt_nodes
{

// Helper function to calculate distance between two poses (2D)
inline double euclidean_distance(
  const geometry_msgs::msg::Pose & p1,
  const geometry_msgs::msg::Pose & p2)
{
  return std::hypot(p1.position.x - p2.position.x, p1.position.y - p2.position.y);
}

AdvancedRemovePassedGoalsAction::AdvancedRemovePassedGoalsAction(
  const std::string & xml_tag_name,
  const BT::NodeConfiguration & conf)
: BT::StatefulActionNode(xml_tag_name, conf)
{
  node_ = config().blackboard->get<rclcpp::Node::SharedPtr>("node");
  tf_ = config().blackboard->get<std::shared_ptr<tf2_ros::Buffer>>("tf_buffer");
  clock_ = node_->get_clock();
  logger_ = node_->get_logger();

  getInput("search_radius", search_radius_);
  int hysteresis_int;
  getInput("hysteresis_indices", hysteresis_int);
  hysteresis_indices_ = static_cast<unsigned int>(hysteresis_int);
  getInput("max_path_deviation", max_path_deviation_);
  getInput("global_frame", global_frame_);
  getInput("robot_base_frame", robot_base_frame_);
  double transform_tolerance_secs;
  getInput("transform_tolerance", transform_tolerance_secs);
  transform_tolerance_ = rclcpp::Duration::from_seconds(transform_tolerance_secs);
}

BT::PortsList AdvancedRemovePassedGoalsAction::providedPorts()
{
  return {
    BT::InputPort<std::vector<geometry_msgs::msg::PoseStamped>>("input_goals", "Original list of goals"),
    BT::InputPort<nav_msgs::msg::Path>("input_path", "The path generated by the planner"),
    BT::OutputPort<std::vector<geometry_msgs::msg::PoseStamped>>("output_goals", "Filtered list of goals with passed ones removed"),
    BT::InputPort<double>("search_radius", 2.0, "Physical distance (m) to define the search window for robot's progress"),
    BT::InputPort<int>("hysteresis_indices", 5, "Number of indices past the target index to confirm a goal is passed"),
    BT::InputPort<double>("max_path_deviation", 1.5, "Max distance (m) the robot can be from the path before failing"),
    BT::InputPort<std::string>("global_frame", "map", "Global frame for TF"),
    BT::InputPort<std::string>("robot_base_frame", "base_link", "Robot base frame for TF"),
    BT::InputPort<double>("transform_tolerance", 0.1, "Transform tolerance in seconds")
  };
}

BT::NodeStatus AdvancedRemovePassedGoalsAction::onStart()
{
  RCLCPP_DEBUG(logger_, "AdvancedRemovePassedGoalsAction: onStart");

  // Reset all state variables when the node is started
  last_path_hash_ = 0;
  waypoint_to_path_index_map_.clear();
  last_progress_index_ = 0;
  if (!getInput("input_goals", initial_goals_)) {
    RCLCPP_WARN(logger_, "input_goals not provided, cannot initialize.");
    return BT::NodeStatus::FAILURE;
  }

  return BT::NodeStatus::RUNNING;
}

void AdvancedRemovePassedGoalsAction::onHalted()
{
  RCLCPP_DEBUG(logger_, "AdvancedRemovePassedGoalsAction: onHalted");
}

BT::NodeStatus AdvancedRemovePassedGoalsAction::onRunning()
{
  // 1. Get inputs from blackboard
  std::vector<geometry_msgs::msg::PoseStamped> current_goals;
  nav_msgs::msg::Path path;

  if (!getInput("input_goals", current_goals) || !getInput("input_path", path)) {
    RCLCPP_WARN(logger_, "input_goals or input_path not available on the blackboard.");
    return BT::NodeStatus::FAILURE;
  }

  // 2. Defensive checks
  if (current_goals.empty()) {
    setOutput("output_goals", current_goals);
    return BT::NodeStatus::SUCCESS;
  }
  if (path.poses.size() < 2) {
    RCLCPP_WARN(logger_, "Path is too short to process. Passing goals through.");
    setOutput("output_goals", current_goals);
    return BT::NodeStatus::SUCCESS; // Not a failure, just can't process
  }

  // 3. Path Validation: Check if the path has been replanned
  if (isPathUpdated(path)) {
    RCLCPP_INFO(logger_, "New path detected. Re-initializing waypoint-to-path index map.");
    last_progress_index_ = 0;
    // Use the original full list of goals for mapping
    createWaypointIndexMapping(path, initial_goals_);
  }

  // 4. Get current robot pose
  geometry_msgs::msg::PoseStamped robot_pose;
  if (!updateRobotPose(robot_pose)) {
    return BT::NodeStatus::FAILURE;
  }
  
  // 5. Find robot's progress along the path using the search window
  size_t current_progress_index = findCurrentProgressIndex(path, robot_pose);
  last_progress_index_ = current_progress_index; // Update anchor for next tick

  // 6. Max Path Deviation Check
  double deviation = euclidean_distance(
    robot_pose.pose, path.poses[current_progress_index].pose);
  if (deviation > max_path_deviation_) {
    RCLCPP_WARN(
      logger_, "Robot deviated from path by %.2f m (max: %.2f m). Returning FAILURE.",
      deviation, max_path_deviation_);
    return BT::NodeStatus::FAILURE;
  }

  // 7. Main goal removal logic
  size_t initial_goals_passed = initial_goals_.size() - current_goals.size();
  while (!current_goals.empty()) {
      size_t current_goal_original_index = initial_goals_passed;

      if (waypoint_to_path_index_map_.find(current_goal_original_index) == waypoint_to_path_index_map_.end()) {
          RCLCPP_WARN(logger_, "Could not find mapping for goal index %zu. Stopping check.", current_goal_original_index);
          break;
      }
      
      size_t target_path_index = waypoint_to_path_index_map_.at(current_goal_original_index);
      
      // Hysteresis Check
      if (current_progress_index > target_path_index + hysteresis_indices_) {
          RCLCPP_INFO(logger_, "Goal %zu passed. Progress index %zu > target index %zu + hysteresis %u.",
              current_goal_original_index, current_progress_index, target_path_index, hysteresis_indices_);
          current_goals.erase(current_goals.begin());
          initial_goals_passed++;
      } else {
          // If the first goal isn't passed, none of the subsequent ones can be.
          break;
      }
  }

  // 8. Set output and return success
  setOutput("output_goals", current_goals);
  return BT::NodeStatus::SUCCESS;
}

bool AdvancedRemovePassedGoalsAction::updateRobotPose(geometry_msgs::msg::PoseStamped & robot_pose)
{
  if (!nav2_util::getCurrentPose(
      robot_pose, *tf_, global_frame_, robot_base_frame_, transform_tolerance_))
  {
    RCLCPP_WARN(logger_, "Failed to get robot pose in %s frame.", global_frame_.c_str());
    return false;
  }
  return true;
}

bool AdvancedRemovePassedGoalsAction::isPathUpdated(const nav_msgs::msg::Path & path)
{
  // Hash the path to get a unique identifier
  std::string path_str;
  path_str.reserve(path.poses.size() * 50); // Pre-allocate for efficiency
  for (const auto & pose : path.poses) {
    path_str += std::to_string(pose.pose.position.x) +
                std::to_string(pose.pose.position.y) +
                std::to_string(pose.pose.orientation.z) +
                std::to_string(pose.pose.orientation.w);
  }
  
  size_t new_hash = std::hash<std::string>{}(path_str);
  if (new_hash != last_path_hash_) {
    last_path_hash_ = new_hash;
    return true;
  }
  return false;
}

void AdvancedRemovePassedGoalsAction::createWaypointIndexMapping(
  const nav_msgs::msg::Path & path,
  const std::vector<geometry_msgs::msg::PoseStamped> & goals)
{
  waypoint_to_path_index_map_.clear();
  if (path.poses.empty() || goals.empty()) {
    return;
  }

  for (size_t i = 0; i < goals.size(); ++i) {
    double min_dist_sq = std::numeric_limits<double>::max();
    size_t best_index = 0;
    for (size_t j = 0; j < path.poses.size(); ++j) {
      double dist_sq = nav2_util::geometry_utils::euclidean_distance_sq(
        goals[i].pose, path.poses[j].pose);
      if (dist_sq < min_dist_sq) {
        min_dist_sq = dist_sq;
        best_index = j;
      }
    }
    waypoint_to_path_index_map_[i] = best_index;
    RCLCPP_DEBUG(logger_, "Mapped goal %zu to path index %zu", i, best_index);
  }
}

size_t AdvancedRemovePassedGoalsAction::findCurrentProgressIndex(
  const nav_msgs::msg::Path & path,
  const geometry_msgs::msg::PoseStamped & robot_pose)
{
  // 1. Determine search window boundaries based on physical distance
  size_t lower_bound = last_progress_index_;
  double cumulative_dist = 0.0;
  for (size_t i = last_progress_index_; i > 0; --i) {
    cumulative_dist += euclidean_distance(path.poses[i].pose, path.poses[i-1].pose);
    if (cumulative_dist > search_radius_) {
      break;
    }
    lower_bound = i - 1;
  }

  size_t upper_bound = last_progress_index_;
  cumulative_dist = 0.0;
  for (size_t i = last_progress_index_; i < path.poses.size() - 1; ++i) {
    cumulative_dist += euclidean_distance(path.poses[i].pose, path.poses[i+1].pose);
    if (cumulative_dist > search_radius_) {
      break;
    }
    upper_bound = i + 1;
  }

  // 2. Find the closest point within the determined window
  double min_dist_sq = std::numeric_limits<double>::max();
  size_t best_index = lower_bound;

  for (size_t i = lower_bound; i <= upper_bound; ++i) {
    double dist_sq = nav2_util::geometry_utils::euclidean_distance_sq(
      robot_pose.pose, path.poses[i].pose);
    if (dist_sq < min_dist_sq) {
      min_dist_sq = dist_sq;
      best_index = i;
    }
  }
  
  return best_index;
}

}  // namespace amr_bt_nodes


// This is the Behavior Tree plugin registration.
// You must in your CMakeLists.txt link this library to BehaviorTreeFactory
#include "behaviortree_cpp/bt_factory.h"
BT_REGISTER_NODES(factory)
{
  factory.registerNodeType<amr_bt_nodes::AdvancedRemovePassedGoalsAction>("AdvancedRemovePassedGoalsAction");
}